Functions/Variables
######################## docs.python.org
print("hello, world") -- print = console.log
input -- prompt, like in inquirer :::: return value is the prompt input [name = input("What's your name?")]

note: (Comments are left with #)
can leave multilines with """ comments """

template literals :::: f"Hello {variable}" [just add an f before the string and brackets around the variable!]

print('hello,', end=' ') #Can actually edit the end option directly (we only know this via the python docs)
print('World') #now they print on the same line, cool right? since the default for print ends with \n

Interesting that "end" is just passed in as an argument and not as an option object

String Methods
#######################
str = str.strip() removes whitespace from str :::: aka .trim in js
str = str.capitalize() capitalizes the first letter (pretty cool)
str = str.title() captializes the first letter of each word

str = str.split(" ") splits it on whitespace into an array [exactly like js]
can even destructure from an array --- first, last = name.split(" ")    [unlike in js where we do const [first,last] = name.split(" ")]

Int Methods
########################
int("1") = 1 :::: [basically parseInt()]
+, -, / , *, %

Float Methods
#######################
float("1.2") = 1.2 :::: [turns the string into a float if applicable]
round(float("1.2")) = 1 :::: [Way better than Math.floor()]
round(float(".3333"), 2) = .33 :::: rounds to 2 decimals
f"{number:,}" :::: [formats the number with commas]
f"{number:.2f}" :::: formats the number to 2 decimals

Functions
#######################
hello() is a function call
def :::: is the keyword to define Functions [indents are important - indent below that code is part of that function]
def hello(): 
    print("hello")

def hello(name="luke"): [can define default values like in JS. very similar def = function]
    print(f"hello {name}")

functions must be above the call in the python script.

New Convention.####### now we can define our functions in any order so long as main is the last thing called
def main():
    name = input("What's your name? ")
    hello(name)

variables are scoped inside of the function to which it belongs [like in JS]

Returns.##########
Same as JS. Just (return x)
[python squares note: x**2, pow(x, 2)]

############################
LOGIC
############################
>, >=, <, <=, ==, != [same as js]
if x < y: [no parenthesis like in js, and instead of {} you use : and indents]

if
elif [else if in javascript (stop asking new questions if we fufill one)]

if score >= 90 and score <= 100: [and instead of && :::: or instead of ||]
    thing

[else is default case like in js]

[honestly, all mostly the same as in JS] :::: no ===, just == :::: 

MATCH.############################

match name: [match = switch in js && _ == default && | can be used for or in match && don't need breaks]
    case "Harry" | "Hermoine" | "Ron:
        print("Gryffindor")
    case "Draco":
        print("Slytherin")
    case _:
        print("Default")

LOOPS.#############################

i = 3
while i > 0:
    print("meow")
    i -= 1 [no i-- in python]

for i in [1,2,3] (will loop 3 times, one for each item in the "list" aka an array)
for i in range(3): (will loop 3 times. for i in range is sick)

common in python to use unused variables like so:
for _ in range(3): 

print("\nmeow" * 3, end='') also meows 3 times 

[(note: indentations mattering is weird)]

while True:
    n = int(input("What's x"))
    if n > 0
        break

LISTS.###################################
[Lists are like JS arrays]
Bracket notation like in JS (students[0])

for student in students: [just like in JS, only with the indent syntax]
    print(student)

for i in range(len(students)): [len instead of .length]
    print(students[i])

DICTS.#####################################
Key value pairs like JS objects
students = {
    "Hermoine": "Gryffindor, 
    "Draco": "Slytherin"
}
students["Hermione"] = Gryffindor

for student in students:
    print(student, students[student]) [this will print all of the keys of the dictionary... and then students[student] gets other value very cool]

can do arrays of objects in this too. 
students = [
    {"name": "Harry", "house": "Griff", "patronus": "Elk"},
    {"name": "Draco", "house": "Sylyth", "patronus": None}
]

for student in students:
    print(student["name"]) [prints each student's name etc...]

None = null in a dictionary

EXCEPTIONS.####################################

try-except blocks [pretty much like try/catch blocks in JS]
 
try:
    x = int(input("what's x? "))
    print(f"x is {x}")
except ValueError:  [could use a generic except instead by just doing except: (bad form, though)]
    print("x is not an integer")    

-----
try:
    x = int(input("what's x? "))
except ValueError:
    print("x is not an integer")

print(f"x is {x}")
[this "NameErrors" because... x = int... is invalid if "cat"]

------fix with
try:
    x = int(input("what's x? "))
except ValueError:
    print("x is not an integer")
else:
    print(f"x is {x}")
    
[can add else at the end of a try except block as a catchall... but its always called... unless an exception happens...]
[else only runs if no exceptions]

[while True loop w/ break to get out is cool but same as JS]
[return also breaks you out of while true loops]

---------pass
def getInt():
    while True:
        try:
            return int(input("what's x? "))
        except ValueError:
            pass
            
[pass just continues the loop from the top?]

MODULES.##############################################
import random
random.choice([1,2,3,4,5])

--from
(from random import choice)[to only import random.choice]
choice([1,2,3,4,5])

random.randint(a,b) -> random number between a and b (cool)
random.shuffle(x) -> takes in a list of values and randomly sorts them in place

-------------------
import statistics

statistics.mean([100, 90]) -> finds the mean (cool)

--------------------
import sys

sys.argv -> list of words typed after python command (like nodejs) 
print("hello, my name is ", sys.argv[1]) -> zzz... sys.argv[0] is the file call so it starts at [1] for the args

--sys guarding

if len(sys.argv) > 1:
    print("hello, my name is ", sys.argv[1])

--sys.exit

if len(sys.argv) < 2:
    sys.exit("Too few arugments") [intentional early exit whole program.]

print("hello, my name is", sys.argv[1])

--slice of a list
sys.argv[1:] [range 1 til ...everything else (mad cool tbh)]
for arg in sys.argv[1:]:
    print("hello, my name is", arg)

argv[1:-1] -> 1 to 1 from the end... epic

-----------------------------------------
PACKAGES

pyPI (python package index)
pip (like npm)

pip install cowsay (to get cowsay package)
if len(sys.argv) == 2:
    cowsay.cow("hello, " + sys.argv[1]) [lol]

---------------------------------------------
APIs

requests package
pip install requests

import requests
import sys

if len(sys.argv) != 2:
    sys.exit("no")

response = requests.get(
    "https://itunes.apple.com/search?entity=song&limit=1&term=" + sys.argv[1])
print(response.json())

[Very nice. Appears to be synchronus (blocks code below it) automatically]

----------------------------------------------------------
import json
import requests
import sys

if len(sys.argv) != 2:
    sys.exit("no")

response = requests.get(
    "https://itunes.apple.com/search?entity=song&limit=1&term=" + sys.argv[1])
print(json.dumps(response.json(), indent=2))
o = response.json()

for result in o["results"]:
    print(result["trackName"])

[this json.dumps indent=2 formats the json in the command line]

-----------------------------------
module imports

def main():
    hello("world")
    goodbye("world")


def hello(name):
    print(f"hello, {name}")


def goodbye(name):
    print(f"goodbye, {name}")


if __name__ == "__main__": [this bizzare if, basically says: (if this is the main file, run main, if imported, don't.)]
    main()

import sys
from sayings import hello [will run entire file sayings and look to import hello]

if len(sys.argv) == 2:
    hello(sys.argv[1])

UNIT TESTS.##########################################################
assert [asserts something is true. if wrong, you see an error]

def test_square():
    assert square(2) == 4
    assert square(3) == 9

pytest package [like jest i guess]

--in cmdline
python -m pytest test_calculator.py

def test_str():
    with pytest.raises(TypeError):
        square("cat")

-----------------------------------------
Make your own pacakges with __init__.py
$ python -m pytest test [runs the whole folder test if test has __init__.py in it]

######################################################################################
FILE IO.##############################################################################
######################################################################################

-----MORE LIST STUFF
append = [js push]
insert(0, "thing") = [js unshift]

for name in sorted(names):
    print(f"hello, {name}")

loops over a presorted list[interesting]

-----------------
back to fileIO

open -> [opens a file in py]
file = open("names.txt", "w") -> [open a file called names.txt and "w" write to it(recreatese file every time)]

file = open("names.txt", "a") -> [opens a file called names.txt and "a" to open it up for appending]
file.write(f"{name}\n") -> [writes the name to the file (overwrites the whole file)]
file.close() -> [saves the file]

-------------
with -> [function... as... variable I have no idea wtf this does (it autocloses the file apparently though? It opens a context manager for the file object)]
with open("names.txt", "a") as file:
    file.write(f"{name}\n")

--------------
with open("names.txt", "r") as file: [r is for read-mode (lets you read the file)]
    lines = file.readlines() [read lines returns the lines as a list]

for line in lines:
    print(f"hello, {line.rstrip()}") [rstrip gets rid of linebreaks and whitespace]

----------------
with open("names.txt", "r") as file:
    for line in file:
        print(f"hello, {line.rstrip()}")
[this apparently works... idk why... Oh. its because the "file" object is iterable and consists of each line]

----
names = []
with open("names.txt", "r") as file:
    for line in file:
        names.append(line.rstrip())

for name in sorted(names):
    print(f"hello, {name}")
[can sort them with this strategy]

(sorted(names, reverse="True")) will reverse the order of the sort (cool)

----
csvs are cool
Luke,Cool
Dude,Awesome
Harry,Squatter

with open("names.csv", "r") as file:
    for line in file:
        name, adjective = line.rstrip().split(",")
        print(f"hello {name}, you are {adjective}")

[can use split by commas to get an array from line (which isn't actually an array normally, but a string)]
[then use py destructuring to get name and adjective and print it out.]

---
students = []
with open("names.csv", "r") as file:
    for line in file:
        name, adjective = line.rstrip().split(",")
        students.append({"name": name, "adjective": adjective})


def get_name(student):
    return student["name"] -> [btw, higher order function. student is automatically passed in with key=get_name]


for student in sorted(students, key=get_name): [sorted calls get_name and inputs students as an arg]
    print(f"{student['name']} is in {student['adjective']}")

[SICK. Can sort the dictionary based on student["name"]].

---
students = []
with open("names.csv", "r") as file:
    for line in file:
        name, adjective = line.rstrip().split(",")
        students.append({"name": name, "adjective": adjective})

for student in sorted(students, key=lambda student: student["name"]):
    print(f"{student['name']} is in {student['adjective']}")

[lambda is an anonymous function equiv to ()=>{} in JS]

---
CSV library
import csv

with open("students.csv") as file:
    reader = csv.reader(file) ["Reader" returns rows preformatted for csv using the csv library]
    for name, home in reader: [Wow. we can destructure in the start of a for loop. can we do that in JS?]
        students.append({"name": name, "home: home})

[can use DictReader instead of reader if you have a header and refer to the data as row["name"] etc...]
[more robust since the csv can be manipulated more without strict destructuring]

---
CSV library to write csvs
import csv

name = "luke"
home = "cool house"

with open("student.csv", "a") as file:
    writer = csv.writer(file)
    writer.writerow([name, home])

---
or... even better. DictWriter

name = "luke"
home = "cool house"

with open("student.csv", "a") as file:
    writer = csv.DictWriter(file, fieldnames=["name", "home"]) [just make sure to state the headers]
    writer.DictWriter({"name": name, "home", home}) [write the dicts to the file...]

##################################
REGEX#############################
##################################

email = input("What's your email? ").strip()

if "@" in email: 
    print("Valid")
else:
    print("Invalid")

if blank in string automatically checks for truth [like .includes in js]
if @ appears in the string email, its valid here.
this sucks though.

---
if "@" and "." in email:
    print("Valid")
else 
    print("Invalid")

A little better, can use and to expand our expectations.

---
email = input("What's your email? ").strip()

username, domain = email.split("@")

if (username) and ("." in domain):
    print("Valid")
else:
    print("Invalid")
[way better already. two bools with an and mean both must be true]

---
email = input("What's your email? ").strip()

username, domain = email.split("@")

if (username) and ("." in domain) and (domain.endswith(".edu")):
    print("Valid")
else:
    print("Invalid")
[.endswith is self explanatory fortunately - no equiv in JS really]

---------------------------------------
REGEX library
import re

re.search(pattern,string, flags=0)

syntax.........................
. -> any char except newline
* -> 0 or more reps
+ -> 1 or more reps
? -> 0 or 1 reps
{m} -> m reps
{m,n} -> m-n reps
\ -> escape symbol (so we can match literal ., *, +, ?, etc...)
r"" -> indicates raw string passed in exactly as is (always use)
^ -> the start of the string
$ -> the end of the string
[] -> set of characters
[^] -> complementing the set (which means you can't match any of the chars)
[a-zA-Z0-9_] -> set of characters all a-z, A-Z, 0-9, and _
\w -> alphanumeric set
\W -> not alphanumeric set
\s -> whitespace set
\S -> not whitespace set
\d -> digit set
\D -> not digit set
(a|b) -> a or b
(...) a group
(?:...) non-capturing group

flags.....................................................
re.IGNORECASE (ignores upper/lowercase)
re.MULTILINE (ignores linebreaks)
re.DOTALL()

import re

email = input("What's your email? ").strip().lower()

if re.search(".+@.+", email):
    print("valid")
else:
    print("invalid")

---
import re

email = input("What's your email? ").strip().lower() [.lower() is like .toLowerCase()]

if re.search(r"^\w+@\w+\.edu$", email):
    print("valid")
else:
    print("invalid")

---
import re

email = input("What's your email? ").strip()

if re.search(r"^(\w|\.)+@(\w\.)?\w+\.edu$", email, re.IGNORECASE):
    print("valid")
else:
    print("invalid")

---
import re

name = input("What's your name? ").strip()

matches = re.search(r"^(.+), (.+)$", name) -> [matches.groups() returns both "captured" groups in the parenthesis]

if matches:
    last, first = matches.groups()
    name = f"{first}, {last}"
print(f"hello {name}")

WALRUS OPERATOR.###################################
:=
Basically decalres a variable and runs an if on the same line
import re

name = input("What's your name? ").strip()

if matches := re.search(r"^(.+), *(.+)$", name): --> [kind of sick. if matches... and matches = this... assign and ask bool]
    last, first = matches.groups()
    name = f"{first} {last}"


print(f"hello {name}")

---
naive
username = url.replace("https://twitter.com/", "")
print(username)
[find/replace]

---
# still naive
# username = url.removeprefix("https://twitter.com/")
# print(f"Username: {username}")

---
# re solution
username = re.sub("^.*(com/)", "", url)
print(username)

---
BEST solution
# more specific is better
if matches := re.search(r"^(?:https?://)?(?:www\.)?twitter\.com/([\w_]+)$", url, re.IGNORECASE):
    username = matches.group(1)
    print(f"Username: {username}")